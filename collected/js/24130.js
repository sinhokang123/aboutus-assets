// This file was generated by Slater.app - vault.js


// JS for Vault [Dashboard]
gsap.registerPlugin();

let lenis;
let staggerDefault = 0.05;
let durationDefault = 0.8;
let transitionOffset = 225;

CustomEase.create("cubic-default", "0.625, 0.05, 0, 1");
gsap.defaults({ease: "cubic-default", duration: durationDefault});

initPageTransitions();

// globals to hold state
var userProfile = null;
var savedArray  = [];
var notifTimeout = null;

// Animation - Page Loader
function initLoader() {
  
  var tl = gsap.timeline();
  
  tl.call(function () {
    pageTransitionOut();
  }, null, 0);

}

// Animation - Page Leave
function pageTransitionIn() {
  var tl = gsap.timeline();

  tl.call(function () {
    $('.dash-loading').addClass('is--visible');
  }, null, 0);
  
  tl.to($('.dash-main__inner'), {
    autoAlpha: 0,
    ease: "Power1.easeInOut",
    duration: (transitionOffset - 25) / 1000
  }, 0);
}

// Animation - Page Enter
function pageTransitionOut() {
  var tl = gsap.timeline();

  let limit = 25; // Default for desktop
  
  if (window.matchMedia("(max-width: 991px)").matches) { // Tablet size
    limit = 12;
  } else if (window.matchMedia("(max-width: 767px)").matches) { // Mobile Landscape size
    limit = 6;
  }

  tl.call(function () {
    $('.dash-loading').removeClass('is--visible');
  }, null, 0);
  
  tl.fromTo($('.dash-main__inner'), {
    autoAlpha: 0,
  },{
    autoAlpha: 1,
    ease: "Power3.easeOut",
    duration: (transitionOffset / 1000) * 1,
    //clearProps: "all"
  }, 0);
  
  if (document.querySelector('[data-dash-type="vault"] .dash-main-grid__item, [data-dash-type="basics"] .dash-main-grid__item, [data-dash-type="video"] .dash-main-grid__item, [data-dash-type="saved"] .dash-main-grid__item')) {
    
    // Select items and limit to the determined number
    const itemsResources = document.querySelectorAll('[data-dash-type="vault"] .dash-main-grid__item, [data-dash-type="basics"] .dash-main-grid__item, [data-dash-type="video"] .dash-main-grid__item, [data-dash-type="saved"] .dash-main-grid__item');
    const limitedItemsResources = Array.from(itemsResources).slice(0, limit); // Get the appropriate number of items
    
    tl.fromTo(limitedItemsResources, {
      autoAlpha: 0,
      y: "1em",
      rotate: 0.001,
    },{
      autoAlpha: 1,
      y: "0em",
      rotate: 0.001,
      ease: "Power3.easeOut",
      duration: durationDefault,
      stagger: (staggerDefault / 1.5),
      clearProps: "all"
    }, 0);
  }
  
  if (document.querySelector('[data-dash-type="icons"] .dash-main-grid__item')) {
    
    // Select items and limit to the determined number
    const iconLimit = 80;
    const itemsIcons = document.querySelectorAll('[data-dash-type="icons"] .dash-main-grid__item');
    const limitedItemsIcons = Array.from(itemsIcons).slice(0, iconLimit); // Get the appropriate number of items
    
    tl.fromTo(limitedItemsIcons, {
      autoAlpha: 0,
      y: "1em",
      rotate: 0.001,
    },{
      autoAlpha: 1,
      y: "0em",
      rotate: 0.001,
      ease: "Power3.easeOut",
      duration: durationDefault,
      stagger: (staggerDefault / 4),
      clearProps: "all"
    }, 0);
  }
  
  if (document.querySelector('.dash-res-content')) {
    tl.fromTo($('.dash-res-visual, .dash-res-doc, .dash-res-code, .dash-res-main__icon-btns, .dash-res-more'), {
      autoAlpha: 0,
      y: "1em",
      rotate: 0.001,
    },{
      autoAlpha: 1,
      y: "0em",
      rotate: 0.001,
      ease: "Power3.easeOut",
      duration: durationDefault,
      stagger: (staggerDefault / 1.5),
      clearProps: "all"
    }, 0);
  }
  
  if (document.querySelector('.dash-main__no-saved')) {
    tl.fromTo($('.dash-main__no-saved'), {
      autoAlpha: 0,
    },{
      autoAlpha: 1,
      ease: "Power3.easeOut",
      duration: durationDefault,
    }, 0.2);
  }

}

function initPageTransitions() {

  // # Common: leave (Before Offset)
  async function commonLeaveBeforeOffset(data) {
    pageTransitionIn(data.current);
    resetSearch();
  }

  // # Common: leave (After Offset)
  async function commonLeaveAfterOffset(data) {
    lenis.destroy();
    killAllScrollTriggers();
    data.current.container.remove();
    initBasicFunctions();
    $('[data-dash-nav-status]').attr('data-dash-nav-status', 'not-active');
  }

  // # Common: enter
  async function commonEnter(data) {
    if (data.next.namespace === 'saved') {
      await filterSavedItems();
    }
    pageTransitionOut(data.next);
    initBarbaNavUpdate(data);
    initDashSide();
  }

  // # Common: beforeEnter
  async function commonBeforeEnter(data) {
    ScrollTrigger.getAll().forEach(t => t.kill());
    initSmoothScroll(data.next.container);
    
    // Check if the previous page's URL includes "/video"
    const previousUrl = data.current.url.path || data.current.url.href;
    if (previousUrl && previousUrl.includes('/video')) {
      $('[data-dash-res-video]').attr('data-dash-res-video', 'active');
    }
    
    initScript(data);
  }

  // # Common: afterEnter
  async function commonAfterEnter(data) {
    window.scrollTo(0, 0);
    ScrollTrigger.refresh();
  }

  barba.init({
    sync: true,
    debug: false,
    timeout: 7000,
    preventRunning: true,
    prevent: function ({ el }) {
      if (el.hasAttribute("data-barba-prevent")) {
        return true;
      }
    },
    transitions: [
      {
      name: 'self',
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    },{
      name: 'default',
      // edit ilja: async once
      async once(data) {
        await fetchOutsetaData()
        if (data.next.namespace === 'saved') {
          await filterSavedItems();
        }
        initSmoothScroll(data.next.container);
        initBasicFunctionsOnce();
        initDashSide();
        initDashCountOnce();
        initListSearch();
        initScript(data);
        initLoader();
      },
      async leave(data) {
        await commonLeaveBeforeOffset(data);
        await delay(transitionOffset);
        await commonLeaveAfterOffset(data);
      },
      async enter(data) {
        await commonEnter(data);
      },
      async beforeEnter(data) {
        await commonBeforeEnter(data);
      },
      async afterEnter(data) {
        await commonAfterEnter(data);
      }
    }]
  });

  function initSmoothScroll(container) {
    initLenis();
    ScrollTrigger.refresh();
  }

  // Function to kill all ScrollTrigger data
  function killAllScrollTriggers() {
    if (typeof ScrollTrigger !== 'undefined') {
      ScrollTrigger.killAll(); // Kill all ScrollTrigger instances
    }
  }

  // Reset scroll on page next
  history.scrollRestoration = "manual";
}

function initLenis() {

  // Lenis: https://github.com/studio-freight/lenis
  lenis = new Lenis({
    // duration: 1,
    lerp: 0.165,
    wheelMultiplier: 1.25,
    prevent: (element) => {
      if (element.closest('.o--Widget--widget')) return true;
      return false;
    }
  });

  lenis.on('scroll', ScrollTrigger.update);

  gsap.ticker.add((time) => {
    lenis.raf(time * 1000);
  });

  gsap.ticker.lagSmoothing(0);
}

// Don't touch
function delay(n) {
  n = n || 2000;
  return new Promise((done) => {
    setTimeout(() => {
      done();
    }, n);
  });
}

/**
 * Fire all scripts on page load & switch
 */
function initScript(data) {
  initRemoveWebflowCollectionList(); // Needs to be before: initSavedToggles()
  initPlausibleCustomEvents(); // Needs to be before: initSavedToggles()
  initSavedToggles();
  initDashCount();
  initNewBadgeCards();
  initBasicFunctions();
  initLenisCheckScrollUpDown();
  initScrollToAnchorLenis();
  initScrollTriggerPlayVideoInview();
  initPlayVideoHover();
  initVimeoPlayer();
  initModalBasic();
}

/**
 * Barba Update Links outside Main on page Transition
 */
function initBarbaNavUpdate(data) {
  const updateItems = $(data.next.html).find('[data-barba-update]');

  $('.dash-side [data-barba-update]').each(function (index) {
    const nextItem = $(updateItems[index]);

    if (nextItem.length) {
      // Update 'aria-current' attribute
      const newStatus = nextItem.attr('aria-current');

      if (newStatus !== undefined) {
        $(this).attr('aria-current', newStatus);
      } else {
        $(this).removeAttr('aria-current');
      }

      // Update class list
      const newClassList = nextItem.attr('class');
      $(this).attr('class', newClassList);
    }
  });
  
}

/**
 * Dash Side Navigation Update
 */
function initDashSide() {
  
  // Update Type Button
  $('.dash-type-btn').each(function () {
    var dashTypeBtn = $(this);
    var dashTypeSlug = $(this).attr('data-type-slug');
    if ($('main[data-dash-type]').attr('data-dash-type') === dashTypeSlug) {
      dashTypeBtn.addClass('is--active');
    }
  });
  
  // Update Cat Button
  $('.dash-cat-btn').each(function () {
    var dashCatBtn = $(this);
    var dashTypeSlug = $(this).attr('data-type-slug');
    var dashCatSlug = $(this).attr('data-cat-slug');
    if ($('main[data-dash-type="vault"][data-dash-vault-cat]').attr('data-dash-vault-cat') === dashCatSlug) {
      dashCatBtn.addClass('is--active');
    }
  });
  
  // Update Link for Breadcrumb
  $('.dash-main-top__parent').each(function () {
    var correctSlug = $(this).closest('[data-dash-type]').attr('data-dash-type');
    $(this).attr('href', '/' + correctSlug);
  });
  
}

/**
 * Dash Count Once
 */
 
// Object to store counts per type and category
var counts = {
  vault: {
    total: 0,
    categories: {}
  },
  video: {
    total: 0,
    categories: {}
  },
  basics: {
    total: 0,
    categories: {}
  },
  icons: {
    total: 0,
    categories: {}
  }
};


function initDashCountOnce() {
  
  // Select all resource elements
  var resources = $('.dash-sitemap').find('[sm-resource-slug], [sm-icon-slug]');

  resources.each(function() {
    var $resource = $(this);

    // Check for vault type
    if ($resource.attr('sm-type-vault') === 'true') {
      counts.vault.total += 1; // Increment total count for vault

      var cat = $resource.attr('sm-vault-cat');
      cat = cat ? cat : 'uncategorized';
      counts.vault.categories[cat] = (counts.vault.categories[cat] || 0) + 1;
    }

    // Check for video type
    if ($resource.attr('sm-type-video') === 'true') {
      counts.video.total += 1; // Increment total count for video

      var cat = $resource.attr('sm-video-cat');
      cat = cat ? cat : 'uncategorized';
      counts.video.categories[cat] = (counts.video.categories[cat] || 0) + 1;
    }

    // Check for basics type
    if ($resource.attr('sm-type-basics') === 'true') {
      counts.basics.total += 1; // Increment total count for basics

      var cat = $resource.attr('sm-basics-cat');
      cat = cat ? cat : 'uncategorized';
      counts.basics.categories[cat] = (counts.basics.categories[cat] || 0) + 1;
    }
    
    // Check for icons type
    if ($resource.attr('sm-icon-cat')) {
      counts.icons.total += 1; // Increment total count for icons

      var cat = $resource.attr('sm-icon-cat');
      cat = cat ? cat : 'uncategorized';
      counts.icons.categories[cat] = (counts.icons.categories[cat] || 0) + 1;
    }
    
  });
  
  // Update the Dash Side Navigation Once on load
  updateCountsAndReorder('vault', counts.vault.categories);
  updateCountsAndReorder('basics', counts.basics.categories);
  updateCountsAndReorder('video', counts.video.categories);
  updateCountsAndReorder('icons', counts.icons.categories);

  function updateCountsAndReorder(type, categories) {
    // Update counts for the given type
    $.each(categories, function (cat, count) {
      $('.dash-side .dash-cat-dropdown__list')
      .closest('.dash-side__cat').find('[data-type-slug="' + type + '"]')
      .closest('.dash-side__cat').find('[data-cat-slug="' + cat + '"]')
      .find('.dash-cat-btn__count-text')
      .text(count);
    });
  
    // Reorder categories for the given type
    reorderCategories(type);
  }
  
  function reorderCategories(type) {
    // Find the correct list container using your exact targeting logic
    var $listContainer = $('.dash-side .dash-cat-dropdown__list')
      .closest('.dash-side__cat').find('[data-type-slug="' + type + '"]')
      .closest('.dash-side__cat').find('.dash-cat-dropdown__list');
  
    // Collect all category items into an array
    var $items = $listContainer.find('.dash-cat-dropdown__list-item').toArray();
  
    // Sort items based on the count text
    $items.sort(function (a, b) {
      var countA = parseInt($(a).find('.dash-cat-btn__count-text').text(), 10) || 0;
      var countB = parseInt($(b).find('.dash-cat-btn__count-text').text(), 10) || 0;
      return countB - countA; // Descending order
    });
  
    // Update the CSS `order` property for each item
    $.each($items, function (index, item) {
      // Assign the order based on the sorted position
      $(item).css('order', index);
    });
  }
  
}

/**
 * Dash Count
 */
function initDashCount() {
  $('.dash-main-top__count-number').each(function () {
    var $main = $(this).closest('main');
    var vaultCat = $main.attr('data-dash-vault-cat');
    var videoCat = $main.attr('data-dash-video-cat');
    var basicsCat = $main.attr('data-dash-basics-cat');
    var iconsCat = $main.attr('data-dash-icons-cat');
    var type = $main.attr('data-dash-type');

    if (vaultCat !== undefined || videoCat !== undefined || basicsCat !== undefined || iconsCat !== undefined) {
      // 'data-dash-cat' is defined, get the count for that category under the specified type
      var count = 0;
      if (type === 'vault') {
        count = counts.vault.categories[vaultCat] || 0;
      } else if (type === 'video') {
        count = counts.video.categories[videoCat] || 0;
      } else if (type === 'basics') {
        count = counts.basics.categories[basicsCat] || 0;
      } else if (type === 'icons') {
        count = counts.icons.categories[iconsCat] || 0;
      }
      // Update the text of the element with the count
      $(this).text(count);
    } else if (type === 'vault') {
      $(this).text(counts.vault.total);
    } else if (type === 'video') {
      $(this).text(counts.video.total);
    } else if (type === 'basics') {
      $(this).text(counts.basics.total);
    } else if (type === 'icons') {
      $(this).text(counts.icons.total);
    }
  });
}

/**
 * SVG Download/Copy
 */
$(document).on('click', '[data-svg-copy], [data-svg-download], [data-svg-json]', function (event) {
  const $target = $(event.target); // jQuery-wrapped event target
  const $button = $target.closest('[data-svg-copy], [data-svg-download], [data-svg-json]'); // Identify the button clicked
  const $parentWithSvg = $button.closest('[data-svg]'); // Find the closest parent with `data-svg`
  const $svg = $parentWithSvg.find('svg'); // Find the SVG within the parent

  if ($svg.length) {
    const svgHTML = $svg[0].outerHTML; // Get raw SVG HTML
    const svgSlug = $parentWithSvg.data('svg') || 'icon'; // Extract the `data-svg` attribute or fallback to "icon"

    // Handle Copy to Clipboard
    if ($button.is('[data-svg-copy]')) {
      copyToClipboard(svgHTML); // Copy SVG to clipboard

      // Add the class `.is--clipboard` for visual feedback
      $button.find('span').text('Copied!');
      $('[data-notification="icon-positive"]').attr('data-notification-status', 'active').attr('data-notification-color', 'default');
      $('[data-notification="icon-positive"] .dash-notification__text').text('Copied SVG to clipboard');
      setTimeout(() => {
        $button.find('span').text('Copy');
        $('[data-notification="icon-positive"]').attr('data-notification-status', 'not-active');
      }, 2000);
    }

    // Handle Download SVG
    if ($button.is('[data-svg-download]')) {
      const filename = `${svgSlug}.svg`; // Generate filename from `data-svg`
      downloadSVG(svgHTML, filename); // Download SVG
      
      // Visual feedback
      $('[data-notification="icon-positive"]').attr('data-notification-status', 'active').attr('data-notification-color', 'default');
      $('[data-notification="icon-positive"] .dash-notification__text').text('Downloaded SVG file');
      setTimeout(() => {
        $('[data-notification="icon-positive"]').attr('data-notification-status', 'not-active');
      }, 2000);
    }
    
    // Handle Copy to Webflow
    if ($button.is('[data-svg-json]')) {

      // Visual feedback
      $('[data-notification="icon-positive"]').attr('data-notification-status', 'active').attr('data-notification-color', 'webflow');
      $('[data-notification="icon-positive"] .dash-notification__text').text('Copied SVG to Webflow clipboard');
      setTimeout(() => {
        $('[data-notification="icon-positive"]').attr('data-notification-status', 'not-active');
      }, 2000);
    }
  }
});

// Function to copy text to clipboard
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).catch((err) => {
    console.error('Failed to copy text: ', err);
  });
}

// Function to download SVG as a file
function downloadSVG(svgContent, filename) {
  const blob = new Blob([svgContent], { type: 'image/svg+xml' });
  const url = URL.createObjectURL(blob);

  const $link = $('<a>') // Create a temporary anchor element
    .attr('href', url)
    .attr('download', filename)
    .appendTo('body');

  $link[0].click(); // Trigger download
  $link.remove(); // Remove temporary link
  URL.revokeObjectURL(url); // Revoke the blob URL
}

/**
 * Code Block Copy
 */

$(document).on('click', '[data-code-copy]', function (event) {
  const $button = $(event.target).closest('[data-code-copy]'); // Identify the button clicked
  const $dashCode = $button.closest('.dash-code'); // Find the closest `.dash-code` element
  const $codeBlock = $dashCode.find('pre code'); // Find the `<pre><code>` block within

  if ($codeBlock.length) {
    const codeContent = $codeBlock.text(); // Get the text content of the code block

    // Copy the code content to clipboard
    copyToClipboard(codeContent);

    // Visual feedback
    $button.find('span').text('Copied!');
    $('[data-notification="code-positive"]').attr('data-notification-status', 'active');
    if($button.attr('data-code-copy-text')) {
      var notificationUpdateText = $button.attr('data-code-copy-text');
      $('[data-notification="code-positive"] [data-notification-update-text]').text(notificationUpdateText).attr('data-notification-update-text', notificationUpdateText);
    } else {
      $('[data-notification="code-positive"] [data-notification-update-text]').text('code').attr('data-notification-update-text', '');
    }
    setTimeout(() => {
      $button.find('span').text('Copy');
      $('[data-notification="code-positive"]').attr('data-notification-status', 'not-active');
    }, 2000);
  }
});

// Function to copy text to clipboard
function copyToClipboard(text) {
  navigator.clipboard.writeText(text).catch((err) => {
    // console.error('Failed to copy text: ', err);
    $('[data-notification="code-negative"]').attr('data-notification-status', 'active');
    setTimeout(() => {
      $('[data-notification="code-negative"]').attr('data-notification-status', 'not-active');
    }, 2000);
  });
}

/**
 * Webflow JSON Copy
 */
 
$(document).on('click', '[data-json-copy]', function (event) {
  event.preventDefault();

  const $button = $(event.target).closest('[data-json-copy]'); // Identify the button clicked
  const jsonContent = $button.attr('data-json-copy'); // Get the JSON content from the attribute

  if (jsonContent) {
    try {
      JSON.parse(jsonContent); // Validate JSON
      copyJsonToClipboard(jsonContent);
      
      // If button got the [data-svg-json] attribute for the icons, don't do anything
      if (!$button.is('[data-svg-json]')) {
        // Visual feedback for successful copy
        $button.find('.dash-copy-webflow__p').text('Copied to Webflow!');
        $('[data-notification="code-positive"]').attr('data-notification-status', 'active');
        $('[data-notification="code-positive"] [data-notification-update-text]').text('Webflow').attr('data-notification-update-text', 'Webflow');
        setTimeout(() => {
          $button.find('.dash-copy-webflow__p').text('Copy to Webflow');
          $('[data-notification="code-positive"]').attr('data-notification-status', 'not-active');
        }, 2000);
      }
    } catch (err) {
      console.error('Invalid JSON:', err);
      // Visual feedback for invalid JSON
      $('[data-notification="code-negative"]').attr('data-notification-status', 'active');
      setTimeout(() => {
        $('[data-notification="code-negative"]').attr('data-notification-status', 'not-active');
      }, 2000);
    }
  }
});

// Function to copy JSON to clipboard using 'copy' event and clipboardData.setData
function copyJsonToClipboard(jsonString) {
  const copyJson = (event) => {
    event.preventDefault();
    event.clipboardData.setData('application/json', jsonString);
    event.clipboardData.setData('text/plain', jsonString); // Fallback for unsupported types
  };

  // Add temporary copy listener
  document.addEventListener('copy', copyJson);

  // Execute copy command
  document.execCommand('copy');

  // Clean up the event listener
  document.removeEventListener('copy', copyJson);
}


/**
 * List.js Search (Once)
 */

function initListSearch() {
  const searchModal = document.querySelector('.dash-search__modal');
  const searchInput = document.querySelector('.dash-search-field__input');
  const notFoundMessage = document.querySelector('.dash-search__not-found');
  const searchResultValue = document.querySelector('#search-result-input-value');
  const body = document.querySelector('body');

  const downloadIcon = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M12 17V3" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M20 21H4" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M17 12L12 17L7 12" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';
  
  const webflowIcon = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path fill-rule="evenodd" clip-rule="evenodd" d="M23 5.99999L16.3 19.26H10.01L12.81 13.76H12.68C10.37 16.8 6.91 18.8 2 19.26V13.84C2 13.84 5.15 13.65 7 11.68H2V5.98999H7.61V10.67H7.74L10.03 5.98999H14.28V10.64H14.41L16.79 5.98999H23V5.99999Z" fill="black"></path></svg>';
  
  const previewIcon = '<svg width="24" height="24" viewBox="0 0 24 24" fill="none" xmlns="http://www.w3.org/2000/svg"><path d="M14.1213 9.88073C15.2923 11.0517 15.2923 12.9527 14.1213 14.1257C12.9503 15.2967 11.0493 15.2967 9.8763 14.1257C8.7053 12.9547 8.7053 11.0537 9.8763 9.88073C11.0493 8.70773 12.9493 8.70773 14.1213 9.88073Z" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/><path d="M3 12.0005C3 11.3415 3.152 10.6895 3.446 10.0885C4.961 6.99149 8.309 5.00049 12 5.00049C15.691 5.00049 19.039 6.99149 20.554 10.0885C20.848 10.6895 21 11.3415 21 12.0005C21 12.6595 20.848 13.3115 20.554 13.9125C19.039 17.0095 15.691 19.0005 12 19.0005C8.309 19.0005 4.961 17.0095 3.446 13.9125C3.152 13.3115 3 12.6595 3 12.0005Z" stroke="black" stroke-width="1.5" stroke-linecap="round" stroke-linejoin="round"/></svg>';

  // Initialize List.js for resources
  const optionsResources = {
    valueNames: ['sr__resource__title', { name: 'sr__slug', attr: 'sr-slug' }, 'sr__keywords'],
    item: `
    <li class="sr__li">
      <div class="sr__click is--resource" sr-video-on-hover="not-active" data-video-src="" sr-slug>
        <div class="sr__start is--resource">
          <div class="sr__thumbnail sr__slug" sr-slug>
            <div class="sr__thumbnail__before"></div>
            <img class="sr__thumbnail__img" src="" alt="" />
            <div class="sr__thumbnail__video-wrap">
              <video muted loop webkit-playsinline playsinline src="" class="sr__thumbnail__video"></video>
            </div>
            <div class="sr__thumbnail__border"></div>
          </div>
          <div class="sr__resource__info">
            <p class="sr__resource__title"></p>
            <p class="sr__resource__cat"></p>
          </div>
        </div>
        <div class="sr__end is--resource">
          <a class="dash-command is--preview sr__resource__preview" href="" target="_blank">${previewIcon}</a>
          <a class="dash-command sr__link__open" href=""><span class="dash-command__text">Open</span></a>
        </div>
        <a href="" class="sr__link"></a> 
      </div>
    </li>
    `,
    listClass: 'dash-search__results-list-resources',
    fuzzySearch: {
      searchClass: 'dash-search-field__input',
      location: 0,
      distance: 100,
      threshold: 0.3,
      multiSearch: true
    }
  };

  const valuesResourcesElements = document.querySelectorAll('[data-sm-list="resources"] [sm-resource-slug]');
  const valuesResources = Array.from(valuesResourcesElements)
  .filter(element => 
    element.hasAttribute('sm-type-vault') && element.getAttribute('sm-type-vault') === 'true' ||
    element.hasAttribute('sm-type-video') && element.getAttribute('sm-type-video') === 'true' ||
    element.hasAttribute('sm-type-basics') && element.getAttribute('sm-type-basics') === 'true'
  )
  .map(element => ({
    sr__resource__title: element.getAttribute('sm-resource-title'),
    sr__slug: element.getAttribute('sm-resource-slug'),
    sr__keywords: element.getAttribute('sm-resource-keywords'),
  }));
  
  // Store extra not searchable data
  const valuesResourcesExtra = {};
  valuesResourcesElements.forEach(element => {
    const slug = element.getAttribute('sm-resource-slug');
    valuesResourcesExtra[slug] = {
      sr__link: element.querySelector('[sm-resource-link]').getAttribute('href'),
      sr__link__open: element.querySelector('[sm-resource-link]').getAttribute('href'),
      sr__resource__preview: element.querySelector('[sm-resource-preview-link]').getAttribute('href'),
      sr__click: element.querySelector('[sm-resource-video-link]').getAttribute('href'),
      sr__thumbnail__img: element.querySelector('[sm-resource-img]').getAttribute('src'),
      sr__resource__cat: element.getAttribute('sm-vault-cat-title'),
    };
  });
  
  const listResources = new List('list-resources', optionsResources, valuesResources, valuesResourcesExtra);
  
  listResources.on('updated', function() {
    listResources.matchingItems.forEach(item => {
      const slug = item.values().sr__slug;
      const extraData = valuesResourcesExtra[slug]; // Look up extra data
  
      if (extraData) {
        if (extraData.sr__link) {
          item.elm.querySelector('.sr__link').setAttribute('href', extraData.sr__link);
        }
        if (extraData.sr__link__open) {
          item.elm.querySelector('.sr__link__open').setAttribute('href', extraData.sr__link__open);
        }
        if (extraData.sr__resource__preview) {
          item.elm.querySelector('.sr__resource__preview').setAttribute('href', extraData.sr__resource__preview);
        }
        if (extraData.sr__click) {
          item.elm.querySelector('.sr__click').setAttribute('data-video-src', extraData.sr__click);
        }
        if (extraData.sr__thumbnail__img) {
          item.elm.querySelector('.sr__thumbnail__img').setAttribute('src', extraData.sr__thumbnail__img);
        }
        if (extraData.sr__resource__cat) {
          item.elm.querySelector('.sr__resource__cat').innerHTML = extraData.sr__resource__cat;
        }
      }
    });
    searchHoverVideoPlayPause();
  });
  
  function searchHoverVideoPlayPause() {
    $('.sr__click.is--resource').on('mouseenter', function(){
      updateVideoStateFor($(this));
    }).on('mouseleave', function(){
      updateVideoStateFor($(this));
    });
  }
  
  // Script to play/pause the video on hover but also when class is--highlight is added
  function updateVideoStateFor($container) {
    const $video = $container.find('video');
    if (!$video.length) return;           // no video → skip
    const videoEl = $video.get(0);
  
    const isHovered     = $container.is(':hover');
    const isHighlighted = $container.hasClass('is--highlight');
  
    if (isHovered || isHighlighted) {
      if (!$container.data('video-loaded')) {
        $video.attr('src', $container.data('video-src'));
        $container.data('video-loaded', true);
      }
      videoEl.play();
      $container.attr('sr-video-on-hover', 'active');
    } else {
      $container.attr('sr-video-on-hover', 'not-active');
      setTimeout(() => {
        // use the same class name here!
        if (!$container.is(':hover') && !$container.hasClass('is--highlight')) {
          videoEl.pause();
          videoEl.currentTime = 0;
        }
      }, 200);
    }
  }
  // Initialize List.js for icons
  const optionsIcons = {
    valueNames: ['sr__title', {name: 'sr__click', attr: 'data-svg' }, 'sr__keywords'],
    item: `
    <li class="sr__li">
      <div class="sr__click" data-svg="">
        <div class="sr__start">
          <div class="sr__icon" data-svg-src></div>
          <p class="sr__title"></p>
        </div>
        <div class="sr__end">
          <div class="dash-command" data-svg-copy data-plausible-event="SVG Copy" data-plausible-prop=""><span class="dash-command__text">Copy</span></div>
          <div class="dash-command is--webflow" data-json-copy="" data-plausible-event="SVG Copy Webflow" data-plausible-prop="">${webflowIcon}</div>
          <div class="dash-command is--download" data-svg-download data-plausible-event="SVG Download" data-plausible-prop="">${downloadIcon}</div>
        </div>
      </div>
    </li>
    `,
    listClass: 'dash-search__results-list-icons',
    fuzzySearch: {
      searchClass: 'dash-search-field__input',
      location: 0,
      distance: 100,
      threshold: 0.3,
      multiSearch: true
    }
  };

  const valuesIconsElements = document.querySelectorAll('[data-sm-list="icons"] [sm-icon-slug]');
  const valuesIcons = Array.from(valuesIconsElements).map(element => ({
    sr__title: element.getAttribute('sm-icon-title'),
    sr__click: element.getAttribute('sm-icon-slug'),
    sr__keywords: element.getAttribute('sm-icon-keywords')
  }));
  
  // Store sr__icon and sr__json separately in a lookup object
  const valuesIconsExtra = {};
  valuesIconsElements.forEach(element => {
    const slug = element.getAttribute('sm-icon-slug');
    valuesIconsExtra[slug] = {
      sr__icon: element.getAttribute('sm-icon-svg'),
      sr__json: element.getAttribute('sm-icon-json'),
      sr__plausible_title: element.getAttribute('sm-icon-title')
    };
  });
  
  const listIcons = new List('list-icons', optionsIcons, valuesIcons, valuesIconsExtra);
  
  // Add sr__icon and sr__json dynamically after search updates
  listIcons.on('updated', function() {
    listIcons.matchingItems.forEach(item => {
      const slug = item.values().sr__click; // Get the sm-icon-slug
      const extraData = valuesIconsExtra[slug]; // Look up extra data (sr__icon and sr__json)
  
      if (extraData) {
        // Update the JSON copy attribute
        if (extraData.sr__json) {
          item.elm.querySelector('[data-json-copy]').setAttribute('data-json-copy', extraData.sr__json);
        }
        // Update the icon SVG attribute
        if (extraData.sr__icon) {
          const iconContainer = item.elm.querySelector('[data-svg-src]');
          if (iconContainer) {
            iconContainer.innerHTML = extraData.sr__icon; // Set inner HTML to insert the SVG or content
          }
        }
        // Update all plausible prop elements (fixing the issue)
        if (extraData.sr__plausible_title) {
          const plausibleProps = item.elm.querySelectorAll('[data-plausible-prop]');
          plausibleProps.forEach(el => {
            el.setAttribute('data-plausible-prop', extraData.sr__plausible_title);
          });
        }
      }
    });
  });
  
  // Console log the search 
  
  // listIcons.on('searchComplete', function() {
  //   console.log("Current Searchable Data:", listIcons.matchingItems.map(item => item.values()));
  // });
  
  // Add an event listener for the search input
  
  let highlightedIndex = -1; // Track the currently highlighted item's index
  
  searchInput.addEventListener('input', function () {
    
    const query = searchInput.value.trim();

    // Remove previous highlight (if active)
    if (body.getAttribute('data-dash-search') === 'active') {
      removeHighlight();
      highlightedIndex = -1; // Reset highlight index
    }

    // Update the search result value
    searchResultValue.textContent = query;

    if (query === '') {
      // If the input is empty, clear both lists and hide the not-found message
      listResources.search('not-match-anything-unique-99', ['name']);
      listIcons.search('not-match-anything-unique-99', ['name']);
      notFoundMessage.style.display = 'none'; // Hide not-found message
      searchModal.setAttribute('data-search-scroll-status', 'not-active'); // Input is empty
      return;
    }

    searchModal.setAttribute('data-search-scroll-status', 'active'); // Input has text

    // Perform search on both lists
    listResources.fuzzySearch(query);
    listIcons.fuzzySearch(query);
    
    // Limit Resources list to 10 results
    if (listResources.matchingItems.length > 10) {
      listResources.show(1, 10); // Show only the first 10 items
    }

    // Limit Icons list to 10 results
    if (listIcons.matchingItems.length > 10) {
      listIcons.show(1, 10); // Show only the first 10 items
    }

    // Display or hide the "not-found" message
    const resourcesMatches = listResources.matchingItems.length;
    const iconsMatches = listIcons.matchingItems.length;

    if (resourcesMatches === 0 && iconsMatches === 0) {
      notFoundMessage.style.display = 'block'; // Show not-found message
    } else {
      notFoundMessage.style.display = 'none'; // Hide not-found message

      // Highlight the first result if active
      if (body.getAttribute('data-dash-search') === 'active') {
        const firstResult = document.querySelector('.dash-search__results-list-resources .sr__li .sr__click, .dash-search__results-list-icons .sr__li .sr__click');
        if (firstResult) {
          highlightItem(firstResult);
          highlightedIndex = 0; // Set the first result as the highlighted index
        }
      }
    }
  });

  // Arrow key navigation
  document.addEventListener('keydown', (event) => {
    if (body.getAttribute('data-dash-search') !== 'active') return;

    const results = document.querySelectorAll('.dash-search__results-list-resources .sr__li .sr__click, .dash-search__results-list-icons .sr__li .sr__click');

    if (results.length === 0) return;

    if (event.key === 'ArrowDown') {
      // Move highlight down
      event.preventDefault();
      highlightedIndex = (highlightedIndex + 1) % results.length;
      highlightItem(results[highlightedIndex]);
    } else if (event.key === 'ArrowUp') {
      // Move highlight up
      event.preventDefault();
      highlightedIndex = (highlightedIndex - 1 + results.length) % results.length;
      highlightItem(results[highlightedIndex]);
    }
  });

  // Highlight an item visually without taking focus
  function highlightItem(item) {
    removeHighlight(); // Ensure only one item is highlighted
    item.classList.add('is--highlight'); // Add highlight class for visual indication
    item.scrollIntoView({ block: 'nearest' }); // Ensure the highlighted item is visible
    updateVideoStateFor($(item));
  }

  // Remove the highlight class from all items
  function removeHighlight() {
    const highlighted = document.querySelector('.is--highlight');
    if (highlighted) {
      highlighted.classList.remove('is--highlight');
      updateVideoStateFor($(highlighted));
    }
  }

  // Reset function for search
  window.resetSearch = function () {
    body.setAttribute('data-dash-search', 'not-active');

    setTimeout(() => {
      searchInput.value = ''; // Clear the input field
      removeHighlight(); // Remove any highlights
      searchModal.setAttribute('data-search-scroll-status', 'not-active'); // Hide the search modal
      notFoundMessage.style.display = 'none'; // Hide not-found message
      searchInput.blur(); // Blur the search input

      // Clear search results
      listResources.search('not-match-anything-unique-99', ['title']);
      listIcons.search('not-match-anything-unique-99', ['title']);
    }, 200); // Small delay ensures visibility
  };

  // Handle "Enter" key press to activate the highlighted link
  document.addEventListener('keydown', (event) => {
    if (event.key === 'Enter' && body.getAttribute('data-dash-search') === 'active') {
      const highlighted = document.querySelector('.is--highlight');
      if (!highlighted) return;
  
      // 1) look for the <.sr__link> inside
      const innerLink = highlighted.querySelector('.sr__link');
      if (innerLink) {
        innerLink.click();
      } else {
        // 2) otherwise click the container as before
        highlighted.click();
      }
  
      event.preventDefault();
    }
  });
  
  // Clear both lists on page load
  listResources.search('not-match-anything-unique-99', ['title']);
  listIcons.search('not-match-anything-unique-99', ['title']);
}


/**
 * New Badge Card
 */
function initNewBadgeCards() {

  // Select all elements that have a data-res-date attribute
  const elements = document.querySelectorAll('[data-card-date]');

  // Get today's date at midnight (no timezone handling as requested)
  const today = new Date();
  // Normalize today to start of the day for consistent day-difference checks
  today.setHours(0, 0, 0, 0);

  elements.forEach(el => {
    const dateStr = el.getAttribute('data-card-date'); // format D/M/YYYY
    const [day, month, year] = dateStr.split('/').map(Number);

    // Construct date object from attribute (month is zero-based in JS)
    const publishedDate = new Date(year, month - 1, day);
    publishedDate.setHours(0, 0, 0, 0);

    // Calculate the difference in days
    const diffInMs = today - publishedDate;
    const diffInDays = diffInMs / (1000 * 60 * 60 * 24);

    // Show the badge if published date is within the last 7 days (0 to 6 days ago)
    if (diffInDays >= 0 && diffInDays < 7) {
      const badge = document.createElement('div');
      badge.className = 'dash-badge-new';
      badge.innerHTML = '<span class="dash-badge__text">New</span>';
      el.appendChild(badge);
    }
  });
}

/**
 * Basic Functions
 */
function initBasicFunctions() {

  // Toggle Navigation
  $('[data-dash-nav-toggle="toggle"]').click(function () {
    if ($('[data-dash-nav-status]').attr('data-dash-nav-status') == 'not-active') {
      $('[data-dash-nav-status]').attr('data-dash-nav-status', 'active');
    } else {
      $('[data-dash-nav-status]').attr('data-dash-nav-status', 'not-active');
    }
  });

// Close Navigation
$('[data-dash-nav-toggle="close"]').click(function () {
  $('[data-dash-nav-status]').attr('data-dash-nav-status', 'not-active');
});
  
  // Dash Side Collapse
  $('[data-dash-collapsed-toggle]').click(function () {
    if ($('[data-dash-collapsed]').attr('data-dash-collapsed') == 'false') {
      $('[data-dash-collapsed]').attr('data-dash-collapsed', 'true');
      Cookies.set('dash-collapsed', 'true', { expires: 365 });
    } else {
      $('[data-dash-collapsed]').attr('data-dash-collapsed', 'false');
       Cookies.set('dash-collapsed', 'false', { expires: 365 });
    }
  });
  
  if (Cookies.get('dash-collapsed') == 'true') {
    $('[data-dash-collapsed]').attr('data-dash-collapsed', 'true');
  }  
  
  // Webflow Preference
  $('[data-dash-documentation-toggle]').click(function () {
    if ($('[data-dash-documentation]').attr('data-dash-documentation') == 'webflow') {
      $('[data-dash-documentation]').attr('data-dash-documentation', 'code');
      Cookies.set('dash-documentation', 'code', { expires: 365 });
    } else {
      $('[data-dash-documentation]').attr('data-dash-documentation', 'webflow');
       Cookies.set('dash-documentation', 'webflow', { expires: 365 });
    }
  });
  
  if (Cookies.get('dash-documentation') == 'code') {
    $('[data-dash-documentation]').attr('data-dash-documentation', 'code');
  }  
  
  // Toggle Player/Preview
  $('[data-dash-res-video-toggle="toggle"]').click(function () {
    if ($('[data-dash-res-video]').attr('data-dash-res-video') == 'not-active') {
      $('[data-dash-res-video]').attr('data-dash-res-video', 'active');
    } else {
      $('[data-dash-res-video]').attr('data-dash-res-video', 'not-active');
    }
  });

  // Show Player
  $('[data-dash-res-video-toggle="player"]').click(function () {
    $('[data-dash-res-video]').attr('data-dash-res-video', 'active');
  });
  
  // Show Preview
  $('[data-dash-res-video-toggle="preview"]').click(function () {
    $('[data-dash-res-video]').attr('data-dash-res-video', 'not-active');
  });
  
  // Toggle Dark/Light (For production)
  
  function addLoading() {
    $('.dash-loading').addClass('is--visible-theme-switch');
    setTimeout(function() {
      $('.dash-loading').removeClass('is--visible-theme-switch');
    }, 200);
  }
  
  function initDashThemeCheck() {
    if ($('[data-dash-theme]').attr('data-dash-theme') == 'light') {
      $('[data-dash-theme]').attr('data-dash-theme', 'dark');
      Cookies.set('dash-theme', 'dark', { expires: 365 });
      addLoading();
    } else {
      $('[data-dash-theme]').attr('data-dash-theme', 'light');
      Cookies.set('dash-theme', 'light', { expires: 365 });
      addLoading();
    }
  }
  
  $(document).on('keydown', function(e) {
    // Prevent action if typing in an input or textarea
    const tagName = e.target.tagName.toLowerCase();
    if (tagName === 'input' || tagName === 'textarea' || e.target.isContentEditable) {
      return; // Exit early
    }
    // Dash Dark/Light
    if (e.shiftKey && e.keyCode === 84) {
      e.preventDefault();
      initDashThemeCheck();
    }
  });
  
  $('[data-dash-theme-toggle]').click(function(){ 
    initDashThemeCheck();
  });

  if (Cookies.get('dash-theme') == 'dark') {
    $('[data-dash-theme]').attr('data-dash-theme', 'dark');
  }   
  
  // Toggle Search Modal
  function initDashSearch() {
    if ($('[data-dash-search]').attr('data-dash-search') == 'not-active') {
      $('[data-dash-search]').attr('data-dash-search', 'active');
      setTimeout(() => {
        $('.dash-search-field__input').focus();
      }, 300); // Small delay ensures visibility
    } else {
      $('[data-dash-search]').attr('data-dash-search', 'not-active');
      resetSearch();
    }
  }
  
  // Open Search
  $(document).on('keydown', function(e) {
    // Prevent action if typing in an input or textarea
    const tagName = e.target.tagName.toLowerCase();
    if (tagName === 'input' || tagName === 'textarea' || e.target.isContentEditable) {
      return; // Exit early
    }
    // Check for Command + K (macOS) or Ctrl + K (Windows/Linux)
    if ((e.metaKey || e.ctrlKey) && (e.keyCode === 69 || e.keyCode === 75)) {
      e.preventDefault();
      initDashSearch();
      plausible('Open Search (Keyboard)');
    }
  });
  
  $('[data-dash-search-toggle]').click(function(){ 
    initDashSearch();
  });
  
  // Close Search
  $(document).on('keydown', function(e) {
    if (e.keyCode === 27 && $('[data-dash-search]').attr('data-dash-search') == 'active') {
      e.preventDefault();
      resetSearch();
    }
  });
  
  $('[data-dash-search-close]').click(function(){ 
    resetSearch();
  });
  
  // Take SVG from [data-svg-src]
  $('.dash-icon-card [data-svg-src]').each(function () {
    const singleSVG = $(this);
    const singleSVGSource = singleSVG.attr('data-svg-src');
    singleSVG.attr('data-svg-src', '');
    singleSVG.html(singleSVGSource);
  });
  
  // Add target blank to element with this attr
  $('[data-external-link]').attr('target', '_blank');

}

/**
 * Basic Functions Once (Run only on Load)
 */
function initBasicFunctionsOnce() {
    $(document).on('keydown', function(e) {
      
    // Prevent action if typing in an input or textarea
    const tagName = e.target.tagName.toLowerCase();
    if (tagName === 'input' || tagName === 'textarea' || e.target.isContentEditable) {
      return; // Exit early
    }
    
    // Dash Side Commands
    // Shift + 1
    if (e.shiftKey && e.keyCode === 49) {
      e.preventDefault();
      $('[data-command="shift+1"]')[0].click();
    }
    // Shift + 2
    if (e.shiftKey && e.keyCode === 50) {
      e.preventDefault();
      $('[data-command="shift+2"]')[0].click();
    }
    // Shift + 3
    if (e.shiftKey && e.keyCode === 51) {
      e.preventDefault();
      $('[data-command="shift+3"]')[0].click();
    }
    // Shift + 4
    if (e.shiftKey && e.keyCode === 52) {
      e.preventDefault();
      $('[data-command="shift+4"]')[0].click();
    }
    // Shift + 50
    if (e.shiftKey && e.keyCode === 53) {
      e.preventDefault();
      $('[data-command="shift+5"]')[0].click();
    }
  });
}


/**
 * Lenis - Check Scroll up or Down
 */

function initLenisCheckScrollUpDown() {

  var lastScrollTop = 0;
  var threshold = 50;
  var thresholdTop = 50;

  var scrollHandler = function (e) {
    var nowScrollTop = e.targetScroll;

    if (Math.abs(lastScrollTop - nowScrollTop) >= threshold) {

      // Check Scroll Direction
      if (nowScrollTop > lastScrollTop) {
        $("[data-scrolling-direction]").attr('data-scrolling-direction', 'down');
      } else {
        $("[data-scrolling-direction]").attr('data-scrolling-direction', 'up');
      }
      lastScrollTop = nowScrollTop;

      // Check if Scroll Started
      if (nowScrollTop > thresholdTop) {
        $("[data-scrolling-started]").attr('data-scrolling-started', 'true');
      } else {
        $("[data-scrolling-started]").attr('data-scrolling-started', 'false');
      }
    }
  };

  function startCheckScroll() {
    lenis.on('scroll', scrollHandler);
  }

  function stopCheckScroll() {
    lenis.off('scroll', scrollHandler);
  }

  // Initialize the scroll check
  startCheckScroll();

  // Cleanup before leaving the page
  barba.hooks.beforeLeave(() => {
    stopCheckScroll(); // Clean up the scroll event listeners
    lastScrollTop = 0; // Reset scroll tracking data
  });

  // Reinitialize after page transition
  barba.hooks.after(() => {
    startCheckScroll(); // Reattach the scroll event listeners
  });
}

/**
 * Lenis - ScrollTo Anchor Links
 */
function initScrollToAnchorLenis() {

  $("[data-anchor-target]").click(function () {

    let targetScrollToAnchorLenis = $(this).attr('data-anchor-target');
    lenis.scrollTo(targetScrollToAnchorLenis, {
      easing: (x) => (x < 0.5 ? 8 * x * x * x * x : 1 - Math.pow(-2 * x + 2, 4) / 2),
      duration: durationDefault,
    });

  });
}

/**
 * Play Video Inview
 */
function initScrollTriggerPlayVideoInview() {

  let allVideoDivs = gsap.utils.toArray('[data-video="playpause"]');

  allVideoDivs.forEach((videoDiv, i) => {

    let videoElem = videoDiv.querySelector('video')

    ScrollTrigger.create({
      trigger: videoElem,
      start: '0% 100%',
      end: '100% 0%',
      onEnter: () => videoElem.play(),
      onEnterBack: () => videoElem.play(),
      onLeave: () => videoElem.pause(),
      onLeaveBack: () => videoElem.pause(),
    });
  });
}

/**
* Play Video on Hover
*/
function initPlayVideoHover() {
   
  $('[data-video-on-hover]').each(function () {
    let video = $(this);
    let videoSRC = video.attr('data-video-src');
    let videoElement = video.find('video');
    if(videoSRC !== '') {
      video.on('mouseenter', function() {
        // Only place the src at first hover
        if(video.find('video').attr('src') === '') {
          video.find('video').attr('src', videoSRC);
        }
        video.attr('data-video-on-hover', 'active');
        videoElement.trigger('play');
      });
      video.on('mouseleave', function() {
        video.attr('data-video-on-hover', 'not-active');
        setTimeout(function() {
          videoElement.trigger('pause');
          videoElement.get(0).currentTime = 0;
        }, 200);
      });
    }
  });
}

/**
* Vimeo Player
*/
function initVimeoPlayer() {
  // Select all elements that have [data-vimeo-player-init]
  const vimeoPlayers = document.querySelectorAll('[data-vimeo-player-init]');

  vimeoPlayers.forEach(function(vimeoElement, index) {
    
    // Add Vimeo URL ID to the iframe [src]
    // Looks like: https://player.vimeo.com/video/1019191082
    const vimeoVideoID = vimeoElement.getAttribute('data-vimeo-video-id');
    if (!vimeoVideoID) return;
    const vimeoVideoURL = `https://player.vimeo.com/video/${vimeoVideoID}?api=1&background=1&autoplay=0&loop=0&muted=1`;
    vimeoElement.querySelector('iframe').setAttribute('src', vimeoVideoURL);
    
    // Assign an ID to each element
    const videoIndexID = 'vimeo-player-index-' + index;
    vimeoElement.setAttribute('id', videoIndexID);

    const iframeID = vimeoElement.id;
    const player = new Vimeo.Player(iframeID);

    // Update Aspect Ratio if [data-vimeo-update-size="true"]
    if (vimeoElement.getAttribute('data-vimeo-update-size') === 'true') {
      player.getVideoWidth().then(function(width) {
        player.getVideoHeight().then(function(height) {
          const beforeEl = vimeoElement.querySelector('.vimeo-player__before');
          if (beforeEl) {
            beforeEl.style.paddingTop = (height / width) * 100 + '%';
          }
        });
      });
    }

    // Loaded
    player.on('play', function() {
      vimeoElement.setAttribute('data-vimeo-loaded', 'true');
    });

    // Autoplay
    if (vimeoElement.getAttribute('data-vimeo-autoplay') === 'false') {
      // Autoplay = false
      player.setVolume(1);
      player.pause();
    } else {
      // Autoplay = true
      player.setVolume(0);
      vimeoElement.setAttribute('data-vimeo-muted', 'true');

      // If paused-by-user === false, do scroll-based autoplay
      if (vimeoElement.getAttribute('data-vimeo-paused-by-user') === 'false') {
        function checkVisibility() {
          const rect = vimeoElement.getBoundingClientRect();
          const inView = rect.top < window.innerHeight && rect.bottom > 0;
          inView ? vimeoPlayerPlay() : vimeoPlayerPause();
        }

        // Initial check
        checkVisibility();

        // Handle scroll
        window.addEventListener('scroll', checkVisibility);
      }
    }

    // Function: Play Video
    function vimeoPlayerPlay() {
      vimeoElement.setAttribute('data-vimeo-activated', 'true');
      vimeoElement.setAttribute('data-vimeo-playing', 'true');
      player.play();
      plausible('Vimeo Activated (First Play)');
    }

    // Function: Pause Video
    function vimeoPlayerPause() {
      vimeoElement.setAttribute('data-vimeo-playing', 'false');
      player.pause();
    }

    // Click: Play
    const playBtn = vimeoElement.querySelector('[data-vimeo-control="play"]');
    if (playBtn) {
      playBtn.addEventListener('click', function() {
        // Always set volume to 0 first to avoid pop
        player.setVolume(0);
        vimeoPlayerPlay();

        // If muted attribute is 'true', keep volume at 0, else 1
        if (vimeoElement.getAttribute('data-vimeo-muted') === 'true') {
          player.setVolume(0);
        } else {
          player.setVolume(1);
        }
      });
    }

    // Click: Pause
    const pauseBtn = vimeoElement.querySelector('[data-vimeo-control="pause"]');
    if (pauseBtn) {
      pauseBtn.addEventListener('click', function() {
        vimeoPlayerPause();
        // If paused by user => kill the scroll-based autoplay
        if (vimeoElement.getAttribute('data-vimeo-autoplay') === 'true') {
          vimeoElement.setAttribute('data-vimeo-paused-by-user', 'true');
          // Removing scroll listener (if you’d like)
          window.removeEventListener('scroll', checkVisibility);
        }
      });
    }
    
    // Click: [data-dash-res-video-toggle]
    const toggleBtns = vimeoElement.closest('body').querySelectorAll('[data-dash-res-video-toggle], [data-modal-close]');
    toggleBtns.forEach((toggleBtn) => {
      toggleBtn.addEventListener('click', function() {
        vimeoPlayerPause();
      });
    });

    // Click: Mute
    const muteBtn = vimeoElement.querySelector('[data-vimeo-control="mute"]');
    if (muteBtn) {
      muteBtn.addEventListener('click', function() {
        if (vimeoElement.getAttribute('data-vimeo-muted') === 'false') {
          player.setVolume(0);
          vimeoElement.setAttribute('data-vimeo-muted', 'true');
        } else {
          player.setVolume(1);
          vimeoElement.setAttribute('data-vimeo-muted', 'false');
        }
      });
    }

    // Click: Fullscreen
    // Check if Fullscreen API is supported
    const fullscreenSupported = !!(
      document.fullscreenEnabled ||
      document.webkitFullscreenEnabled ||
      document.mozFullScreenEnabled ||
      document.msFullscreenEnabled
    );
    
    const fullscreenBtn = vimeoElement.querySelector('[data-vimeo-control="fullscreen"]');
    
    // Hide the fullscreen button if not supported
    if (!fullscreenSupported && fullscreenBtn) {
      fullscreenBtn.style.display = 'none';
    }
    
    if (fullscreenBtn) {
      fullscreenBtn.addEventListener('click', () => {
        const fullscreenElement = document.getElementById(iframeID);
        if (!fullscreenElement) return;
    
        const isFullscreen =
          document.fullscreenElement ||
          document.webkitFullscreenElement ||
          document.mozFullScreenElement ||
          document.msFullscreenElement;
    
        if (isFullscreen) {
          // Exit fullscreen
          vimeoElement.setAttribute('data-vimeo-fullscreen', 'false');
          (document.exitFullscreen ||
            document.webkitExitFullscreen ||
            document.mozCancelFullScreen ||
            document.msExitFullscreen).call(document);
        } else {
          // Enter fullscreen
          vimeoElement.setAttribute('data-vimeo-fullscreen', 'true');
          plausible('Vimeo Fullscreen');
          (fullscreenElement.requestFullscreen ||
            fullscreenElement.webkitRequestFullscreen ||
            fullscreenElement.mozRequestFullScreen ||
            fullscreenElement.msRequestFullscreen).call(fullscreenElement);
        }
      });
    }
    
    const handleFullscreenChange = () => {
      const isFullscreen =
        document.fullscreenElement ||
        document.webkitFullscreenElement ||
        document.mozFullScreenElement ||
        document.msFullscreenElement;
    
      vimeoElement.setAttribute('data-vimeo-fullscreen', isFullscreen ? 'true' : 'false');
    };
    
    // Add event listeners for fullscreen changes (with vendor prefixes)
    ['fullscreenchange', 'webkitfullscreenchange', 'mozfullscreenchange', 'msfullscreenchange'].forEach(event => {
      document.addEventListener(event, handleFullscreenChange);
    });

    // Convert seconds to mm:ss
    function secondsTimeSpanToHMS(s) {
      let h = Math.floor(s / 3600);
      s -= h * 3600;
      let m = Math.floor(s / 60);
      s -= m * 60;
      return m + ":" + (s < 10 ? '0' + s : s);
    }

    // Duration
    const vimeoDuration = vimeoElement.querySelector('[data-vimeo-duration]');
    player.getDuration().then(function(duration) {
      if (vimeoDuration) {
        vimeoDuration.textContent = secondsTimeSpanToHMS(duration);
      }
      // Update timeline + progress max
      const timelineAndProgress = vimeoElement.querySelectorAll('[data-vimeo-control="timeline"], progress');
      timelineAndProgress.forEach((el) => {
        el.setAttribute('max', duration);
      });
    });

    // Timeline
    const timelineElem = vimeoElement.querySelector('[data-vimeo-control="timeline"]');
    const progressElem = vimeoElement.querySelector('progress');

    function updateTimelineValue() {
      player.getDuration().then(function() {
        const timeVal = timelineElem.value;
        player.setCurrentTime(timeVal);
        if (progressElem) {
          progressElem.value = timeVal;
        }
      });
    }

    if (timelineElem) {
      ['input', 'change'].forEach((evt) => {
        timelineElem.addEventListener(evt, updateTimelineValue);
      });
    }

    // Progress Time & Timeline (timeupdate)
    player.on('timeupdate', function(data) {
      if (timelineElem) {
        timelineElem.value = data.seconds;
      }
      if (progressElem) {
        progressElem.value = data.seconds;
      }
      if (vimeoDuration) {
        vimeoDuration.textContent = secondsTimeSpanToHMS(Math.trunc(data.seconds));
      }
    });

    // Hide controls after hover on Vimeo player
    let vimeoHoverTimer;
    vimeoElement.addEventListener('mousemove', function() {
      if (vimeoElement.getAttribute('data-vimeo-hover') === 'false') {
        vimeoElement.setAttribute('data-vimeo-hover', 'true');
      }
      clearTimeout(vimeoHoverTimer);
      vimeoHoverTimer = setTimeout(vimeoHoverTrue, 3000);
    });

    function vimeoHoverTrue() {
      vimeoElement.setAttribute('data-vimeo-hover', 'false');
    }

    // Video Ended
    function vimeoOnEnd() {
      vimeoElement.setAttribute('data-vimeo-activated', 'false');
      vimeoElement.setAttribute('data-vimeo-playing', 'false');
      player.unload();cl
    }
    player.on('ended', vimeoOnEnd);

  });
}

/**
 * Plausible Custom Events
 */
function initPlausibleCustomEvents() {
  // Toggle Navigation
  $('[data-plausible]').click(function () {
    var plausibleClicked = $(this);
    var plausibleName = plausibleClicked.attr('data-plausible');
    plausible(plausibleName);
  });
  
  $(document).on('click', '[data-plausible-event]', function () {
    var plausibleClicked = $(this);
    var plausibleName = plausibleClicked.attr('data-plausible-event');
    var plausibleProp = plausibleClicked.attr('data-plausible-prop');
    plausible(plausibleName, { props: { method: 'HTTP', name: plausibleProp } });
  });
  
  // Add Plausible Data when Saved is Clicked (Card)
  $('.dash-res-card [data-saved-toggle]').click(function () {
    var plausibleClicked = $(this);
    if (!plausibleClicked.is('[saved]')) {
      var plausibleName = 'Saved (Card)';
      var plausibleProp = plausibleClicked.closest('.dash-res-card').find('h2').text().trim();
      plausible(plausibleName, { props: { method: 'HTTP', name: plausibleProp } });
    }
  });
  
  $('.dash-res-info__icon-btns [data-saved-toggle]').click(function () {
    var plausibleClicked = $(this);
    if (!plausibleClicked.is('[saved]')) {
      var plausibleName = 'Saved (Detail Page)';
      plausible(plausibleName);
    }
  });
}

/**
 * Basic Modal
 */
function initModalBasic() {
  
  const modalGroup = document.querySelector('[data-modal-group-status]');
  const modals = document.querySelectorAll('[data-modal-name]');
  const modalTargets = document.querySelectorAll('[data-modal-target]');
  
  // Open modal
  modalTargets.forEach((modalTarget) => {
    modalTarget.addEventListener('click', function () {
      const modalTargetName = this.getAttribute('data-modal-target');

      // Close all modals
      modalTargets.forEach((target) => target.setAttribute('data-modal-status', 'not-active'));
      modals.forEach((modal) => modal.setAttribute('data-modal-status', 'not-active'));

      // Activate clicked modal
      document.querySelector(`[data-modal-target="${modalTargetName}"]`).setAttribute('data-modal-status', 'active');
      document.querySelector(`[data-modal-name="${modalTargetName}"]`).setAttribute('data-modal-status', 'active');

      // Set group to active
      if (modalGroup) {
        modalGroup.setAttribute('data-modal-group-status', 'active');
      }
    });
  });
  
  // Get the current URL
  const currentUrl = window.location.href;
  if (currentUrl.includes('?modal=')) {
    const modalValue = currentUrl.split('?modal=')[1];
    $('[data-modal-group-status]').attr('data-modal-group-status', 'active');
    $('[data-modal-name="' + modalValue + '"]').attr('data-modal-status', 'active');
  }

  // Close modal
  document.querySelectorAll('[data-modal-close]').forEach((closeBtn) => {
    closeBtn.addEventListener('click', closeAllModals);
  });

  // Close modal on `Escape` key
  document.addEventListener('keydown', function (event) {
    if (event.key === 'Escape') {
      closeAllModals();
    }
  });

  // Function to close all modals
  function closeAllModals() {
    modalTargets.forEach((target) => target.setAttribute('data-modal-status', 'not-active'));
    
    if (modalGroup) {
      modalGroup.setAttribute('data-modal-group-status', 'not-active');
    }
  }
}

/**
 * Remove Webflow Collection and/or List
 */
function initRemoveWebflowCollectionList() {
  // Select all elements with the specified data attributes
  const elementsToRemove = document.querySelectorAll('[data-remove-list], [data-remove-collection]');

  // Loop through the elements in reverse order
  Array.from(elementsToRemove).reverse().forEach((element) => {
    // Move the children of the element to its parent node
    while (element.firstChild) {
      element.parentNode.insertBefore(element.firstChild, element);
    }
    // Remove the original wrapper element
    element.remove();
  });
}


/**
 * Get Outseta Data (for: Saved, Subscription Date)
 */
 
// Fetch Profile from Outseta
function fetchProfile() {
  return Outseta.getUser().catch(function() {
    return null;
  });
}

// Convert the profile’s SavedResources JSON into an array of slugs
function getSavedArray(profile) {
  if (!profile || !profile.SavedResources) return [];
  try {
    return JSON.parse(profile.SavedResources);
  } catch {
    return [];
  }
}

// Persist the in-memory savedArray back to the user’s profile
function persistSaved() {
  if (!userProfile) return;
  userProfile.update({
    SavedResources: JSON.stringify(savedArray)
  });
}

function fetchOutsetaData() {
  return fetchProfile().then(function(profile) {
    
    // 1. Save Function
    userProfile = profile;
    savedArray  = getSavedArray(profile);

    var items = document.querySelectorAll('.dash-sitemap [sm-resource-slug]');
    items.forEach(function(el) {
      var slug = el.getAttribute('sm-resource-slug');
      var idx  = savedArray.indexOf(slug);
      if (idx > -1) el.setAttribute('sm-saved', idx);
      else          el.removeAttribute('sm-saved');
    });

    syncBookmarkToggles();
    attachBookmarkHandlers();
    
    // 2. Current Subscription Days Function
    function daysSince(dateString) {
      const start = new Date(dateString);
      const now   = new Date();
    
      // Compute difference in milliseconds…
      const diffMs = now.getTime() - start.getTime();
    
      // …then convert to days
      const msPerDay = 1000 * 60 * 60 * 24;
      return Math.floor(diffMs / msPerDay);
    }
    
    document.querySelectorAll('[data-update-days]').forEach(function(el) {
      el.textContent = daysSince(profile.Account.CurrentSubscription.StartDate);
    });

  });
}

/* Bookmark-Toggle Button Synchronization */

// Reflect the sitemap’s sm-saved attributes on each “bookmark” toggle
function syncBookmarkToggles() {
  var buttons = document.querySelectorAll('[data-saved-toggle]');
  buttons.forEach(function(btn) {
    var item  = btn.closest('[data-saved-res-slug]');
    var slug  = item && item.getAttribute('data-saved-res-slug');
    var site  = slug && document.querySelector('.dash-sitemap [sm-resource-slug="' + slug + '"]');
    if (site && site.hasAttribute('sm-saved')) btn.setAttribute('saved', '');
    else                                       btn.removeAttribute('saved');
  });
}

// Simple bounce-on-click handler
function handleBookmarkAnimate(e) {
  e.currentTarget.setAttribute('animate', '');
}


/* Bookmark-Toggle Logic */

// Called when a bookmark toggle is clicked: update savedArray, re-stamp sitemap, refresh UI
function handleSaveToggleClick(e) {
  var btn   = e.currentTarget;
  var item  = btn.closest('[data-saved-res-slug]');
  if (!item) return;

  var slug      = item.getAttribute('data-saved-res-slug');
  var oldIndex  = savedArray.indexOf(slug);
  var isRemoval = oldIndex > -1;

  // Add or remove the slug in our array
  if (isRemoval) savedArray.splice(oldIndex, 1);
  else           savedArray.push(slug);

  // Save back to Outseta (non-blocking)
  persistSaved();

  // Update this one sitemap element’s sm-saved to its new index
  var sitemapEl = document.querySelector('.dash-sitemap [sm-resource-slug="' + slug + '"]');
  if (sitemapEl) {
    var newIdx = savedArray.indexOf(slug);
    if (newIdx > -1) sitemapEl.setAttribute('sm-saved', newIdx);
    else             sitemapEl.removeAttribute('sm-saved');
  }

  // Refresh all bookmark toggles
  syncBookmarkToggles();

  // If on the “Saved” page, re-filter and re-sort the cards
  if (document.querySelector('main[data-barba-namespace="saved"]')) {
    filterSavedItems();
  }

  // Briefly show positive or negative notification
  clearTimeout(notifTimeout);
  var pos = document.querySelector('[data-notification="saved-positive"]');
  var neg = document.querySelector('[data-notification="saved-negative"]');
  pos.setAttribute('data-notification-status','not-active');
  neg.setAttribute('data-notification-status','not-active');
  var toShow = isRemoval ? neg : pos;
  toShow.setAttribute('data-notification-status','active');
  notifTimeout = setTimeout(function() {
    toShow.setAttribute('data-notification-status','not-active');
  }, 2000);
}

// Wire up each bookmark button for both toggling and bounce animation
function attachBookmarkHandlers() {
  var buttons = document.querySelectorAll('[data-saved-toggle]');
  buttons.forEach(function(btn) {
    btn.removeEventListener('click', handleSaveToggleClick);
    btn.addEventListener('click', handleSaveToggleClick);

    btn.removeEventListener('click', handleBookmarkAnimate);
    btn.addEventListener('click', handleBookmarkAnimate);
  });
}


/* Saved-Page Filtering & Sorting */

// Update the badge showing how many saved cards remain
function updateSavedCount() {
  var count = document.querySelectorAll('.dash-res-card[data-saved-res-slug]').length;
  var badge = document.querySelector('.dash-main-top__count-number');
  if (badge) badge.textContent = count;
}

// On the Saved page, remove any cards no longer marked saved, then sort by sm-saved descending
function filterSavedItems() {
  return new Promise(function(resolve) {
    var firstCard = document.querySelector('.dash-res-card[data-saved-res-slug]');
    if (!firstCard) return resolve();
    var container = firstCard.parentElement.parentElement;

    // Remove cards whose slug lacks an sm-saved attribute
    Array.from(container.querySelectorAll('.dash-res-card[data-saved-res-slug]')).forEach(function(card) {
      var slug = card.getAttribute('data-saved-res-slug');
      var site = document.querySelector('.dash-sitemap [sm-resource-slug="' + slug + '"]');
      if (!site || !site.hasAttribute('sm-saved')) {
        card.parentElement.remove();
      }
    });

    // Collect remaining wrappers and sort by numeric sm-saved (highest first)
    var wrappers = Array.from(container.querySelectorAll('.dash-res-card[data-saved-res-slug]')).map(function(card) { return card.parentElement; });

    wrappers.sort(function(a, b) {
      var slugA = a.querySelector('[data-saved-res-slug]').getAttribute('data-saved-res-slug');
      var slugB = b.querySelector('[data-saved-res-slug]').getAttribute('data-saved-res-slug');
      var idxA  = Number(document.querySelector('.dash-sitemap [sm-resource-slug="' + slugA + '"]').getAttribute('sm-saved'));
      var idxB  = Number(document.querySelector('.dash-sitemap [sm-resource-slug="' + slugB + '"]').getAttribute('sm-saved'));
      return idxB - idxA;
    });

    // Re-append in the new order
    wrappers.forEach(function(wrap) {
      container.appendChild(wrap);
    });

    updateSavedCount();
    resolve();
  });
}

// Initialize bookmark toggles (call this after your page markup is in place)
function initSavedToggles() {
  syncBookmarkToggles();
  attachBookmarkHandlers();
}


